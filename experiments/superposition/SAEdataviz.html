<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Activation Visualizer (NAV)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: #0a0a0f;
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #00d4ff;
            margin-bottom: 5px;
            font-size: 1.8em;
            text-shadow: 0 0 20px rgba(0,212,255,0.5);
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.85em;
        }

        /* Main visualization grid */
        .main-viz {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 30px;
            margin-bottom: 20px;
        }

        .panel {
            background: linear-gradient(135deg, #12121a 0%, #1a1a2e 100%);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #2a2a4a;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: all 0.4s ease;
        }

        .panel.active {
            border-color: #00d4ff;
            box-shadow:
                0 0 30px rgba(0, 212, 255, 0.4),
                0 0 60px rgba(0, 212, 255, 0.2),
                0 10px 40px rgba(0,0,0,0.5);
        }

        .panel.active .panel-title {
            text-shadow: 0 0 10px currentColor;
        }

        .panel.active .panel-title::before {
            box-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff;
            animation: none;
            transform: scale(1.3);
        }

        .panel-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #00d4ff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #00d4ff;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* LEFT PANEL: Model Layers */
        .layers-container {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .layer {
            position: relative;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .layer.active {
            background: rgba(0, 212, 255, 0.1);
            box-shadow:
                0 0 20px rgba(0, 212, 255, 0.3),
                inset 0 0 15px rgba(0, 212, 255, 0.1);
        }

        .layer-label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .layer-neurons {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .neuron {
            aspect-ratio: 1;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            min-height: 28px;
        }

        .neuron:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 0 15px currentColor;
        }

        .neuron::after {
            content: attr(data-val);
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6em;
            color: #666;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .neuron:hover::after {
            opacity: 1;
        }

        /* Data flow arrows between layers */
        .flow-arrow {
            text-align: center;
            padding: 8px 0;
            color: #3a3a5a;
            font-size: 1.4em;
            transition: all 0.3s ease;
        }

        .flow-arrow.active {
            color: #00d4ff;
            text-shadow:
                0 0 10px #00d4ff,
                0 0 20px #00d4ff,
                0 0 30px #00d4ff,
                0 0 40px #00ff88;
            animation: flowPulse 0.4s ease-in-out infinite alternate;
            transform: scale(1.3);
        }

        @keyframes flowPulse {
            0% {
                text-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff;
                transform: scale(1.3) translateY(0);
            }
            100% {
                text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88, 0 0 60px #00ff88;
                transform: scale(1.4) translateY(2px);
            }
        }

        /* MIDDLE PANEL: SAE Visualization */
        .sae-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .sae-diagram {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .sae-stage {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
        }

        .sae-block {
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            text-align: center;
            min-width: 120px;
        }

        .encoder-block {
            background: linear-gradient(135deg, #1e3a5f, #2d5a87);
            border: 2px solid #4a90d9;
            color: #8bc4ff;
            transition: all 0.3s ease;
        }

        .encoder-block.active {
            box-shadow:
                0 0 20px #4a90d9,
                0 0 40px #4a90d9,
                inset 0 0 20px rgba(74, 144, 217, 0.3);
            border-color: #00d4ff;
            transform: scale(1.05);
        }

        .latent-block {
            background: linear-gradient(135deg, #3d1e5f, #5a2d87);
            border: 2px solid #9a4ad9;
            color: #d08cff;
            min-width: 200px;
            transition: all 0.3s ease;
        }

        .latent-block.active {
            box-shadow:
                0 0 20px #9a4ad9,
                0 0 40px #9a4ad9,
                inset 0 0 20px rgba(154, 74, 217, 0.3);
            border-color: #d08cff;
            transform: scale(1.05);
        }

        .decoder-block {
            background: linear-gradient(135deg, #1e5f3a, #2d8757);
            border: 2px solid #4ad97a;
            color: #8cffc4;
            transition: all 0.3s ease;
        }

        .decoder-block.active {
            box-shadow:
                0 0 20px #4ad97a,
                0 0 40px #4ad97a,
                inset 0 0 20px rgba(74, 217, 122, 0.3);
            border-color: #00ff88;
            transform: scale(1.05);
        }

        .sae-arrow {
            color: #4a4a6a;
            font-size: 2em;
            transition: all 0.3s ease;
        }

        .sae-arrow.active {
            color: #00d4ff;
            text-shadow:
                0 0 15px #00d4ff,
                0 0 30px #00d4ff,
                0 0 45px #00ff88;
            animation: saeArrowGlow 0.4s ease-in-out infinite alternate;
            transform: scale(1.2);
        }

        @keyframes saeArrowGlow {
            0% { text-shadow: 0 0 15px #00d4ff, 0 0 30px #00d4ff; }
            100% { text-shadow: 0 0 25px #00ff88, 0 0 50px #00ff88, 0 0 70px #00ff88; }
        }

        /* Sparse activations grid */
        .sparse-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 3px;
            margin: 20px 0;
            padding: 15px;
            background: #0d0d15;
            border-radius: 8px;
        }

        .sparse-cell {
            aspect-ratio: 1;
            border-radius: 3px;
            background: #1a1a2a;
            transition: all 0.3s ease;
            min-height: 18px;
        }

        .sparse-cell.active {
            box-shadow: 0 0 10px currentColor;
        }

        /* Reconstruction quality meter */
        .recon-meter {
            margin-top: 20px;
            padding: 15px;
            background: #0d0d15;
            border-radius: 8px;
        }

        .meter-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            margin-bottom: 8px;
            color: #888;
        }

        .meter-bar {
            height: 12px;
            background: #1a1a2a;
            border-radius: 6px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.5s ease, background 0.5s ease;
        }

        /* RIGHT PANEL: Clean Observations */
        .features-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .feature-row {
            background: #0d0d15;
            border-radius: 8px;
            padding: 12px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .feature-row.highlighted {
            border-left-color: #00d4ff;
            background: #151525;
        }

        .feature-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .feature-name {
            font-size: 0.8em;
            color: #ccc;
        }

        .feature-value {
            font-size: 0.85em;
            font-weight: bold;
            font-family: 'SF Mono', monospace;
        }

        .feature-bar {
            height: 8px;
            background: #1a1a2a;
            border-radius: 4px;
            overflow: hidden;
        }

        .feature-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        /* BOTTOM: Flow Timeline */
        .timeline-panel {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #12121a 0%, #1a1a2e 100%);
            border-radius: 12px;
            border: 1px solid #2a2a4a;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .timeline-title {
            font-size: 0.9em;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .timeline-viz {
            display: flex;
            align-items: center;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .timeline-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 80px;
        }

        .timeline-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .timeline-icon.input { background: #2a3a5a; border-color: #4a90d9; color: #4a90d9; }
        .timeline-icon.l1 { background: #3a2a5a; border-color: #9a4ad9; color: #9a4ad9; }
        .timeline-icon.l2 { background: #3a3a5a; border-color: #d9a44a; color: #d9a44a; }
        .timeline-icon.l3 { background: #2a5a3a; border-color: #4ad97a; color: #4ad97a; }
        .timeline-icon.encoder { background: #1e3a5f; border-color: #4a90d9; color: #4a90d9; }
        .timeline-icon.latent { background: #3d1e5f; border-color: #9a4ad9; color: #9a4ad9; }
        .timeline-icon.decoder { background: #1e5f3a; border-color: #4ad97a; color: #4ad97a; }
        .timeline-icon.output { background: #5a3a2a; border-color: #d97a4a; color: #d97a4a; }

        .timeline-icon.active {
            transform: scale(1.3);
            box-shadow:
                0 0 20px currentColor,
                0 0 40px currentColor,
                0 0 60px currentColor,
                inset 0 0 15px rgba(255,255,255,0.3);
            border-width: 3px;
            animation: nodeGlow 0.6s ease-in-out infinite alternate;
        }

        @keyframes nodeGlow {
            0% {
                box-shadow:
                    0 0 20px currentColor,
                    0 0 40px currentColor,
                    0 0 60px currentColor;
                transform: scale(1.3);
            }
            100% {
                box-shadow:
                    0 0 30px currentColor,
                    0 0 60px currentColor,
                    0 0 80px currentColor;
                transform: scale(1.35);
            }
        }

        .timeline-label {
            font-size: 0.7em;
            color: #666;
            text-align: center;
        }

        .timeline-connector {
            width: 40px;
            height: 3px;
            background: #2a2a4a;
            position: relative;
            border-radius: 2px;
        }

        .timeline-connector.active {
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            box-shadow:
                0 0 10px #00d4ff,
                0 0 20px #00d4ff,
                0 0 30px #00ff88;
            animation: connectorGlow 0.4s ease-in-out infinite alternate;
        }

        @keyframes connectorGlow {
            0% { box-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff; }
            100% { box-shadow: 0 0 15px #00ff88, 0 0 30px #00ff88, 0 0 40px #00ff88; }
        }

        .timeline-connector.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: -4px;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #00ffff 0%, transparent 70%);
            border-radius: 50%;
            animation: particleMove 0.5s ease-out infinite;
        }

        .timeline-connector.active::after {
            content: '';
            position: absolute;
            right: -6px;
            top: -5px;
            width: 14px;
            height: 14px;
            background: radial-gradient(circle, #00ff88 0%, transparent 60%);
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
            animation: pulseArrow 0.3s ease-in-out infinite;
        }

        @keyframes particleMove {
            0% { left: -5px; opacity: 1; transform: scale(1); }
            100% { left: 35px; opacity: 0; transform: scale(0.5); }
        }

        @keyframes pulseArrow {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0088ff);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }

        .btn-secondary {
            background: #2a2a4a;
            color: #ccc;
            border: 2px solid #3a3a5a;
            position: relative;
            overflow: hidden;
        }

        .btn-secondary:hover {
            background: #3a3a5a;
            border-color: #00d4ff;
        }

        .btn-secondary.active {
            background: #3a3a5a;
            border-color: #00d4ff;
            color: #00d4ff;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }

        .btn-secondary.selected {
            background: linear-gradient(135deg, #1a3a4a, #2a4a5a);
            border-color: #00d4ff;
            color: #00d4ff;
            box-shadow:
                0 0 20px rgba(0, 212, 255, 0.4),
                0 0 40px rgba(0, 212, 255, 0.2),
                inset 0 0 15px rgba(0, 212, 255, 0.1);
        }

        .btn-secondary.selected::after {
            content: '‚úì';
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 0.7em;
            color: #00ff88;
        }

        /* Stats bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            padding: 15px;
            background: #0d0d15;
            border-radius: 8px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
        }

        /* Color utilities */
        .color-high { color: #ff4444; }
        .color-mid { color: #ffaa44; }
        .color-low { color: #44ff88; }
        .color-zero { color: #2a2a4a; }

        .bg-high { background: #ff4444; }
        .bg-mid { background: #ffaa44; }
        .bg-low { background: #44ff88; }
        .bg-zero { background: #2a2a4a; }

        /* INPUT IMAGE PANEL */
        .input-image-panel {
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #12121a 0%, #1a1a2e 100%);
            border-radius: 12px;
            border: 1px solid #2a2a4a;
            transition: all 0.4s ease;
        }

        .input-image-panel.active {
            border-color: #00d4ff;
            box-shadow:
                0 0 30px rgba(0, 212, 255, 0.4),
                0 0 60px rgba(0, 212, 255, 0.2);
        }

        .input-image-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-section.small {
            min-width: 80px;
        }

        .input-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            padding: 8px;
            background: #0a0a12;
            border-radius: 8px;
            border: 2px solid #2a2a4a;
        }

        .pixel {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .input-type {
            font-size: 0.8em;
            color: #00d4ff;
            font-weight: bold;
        }

        .input-arrow {
            font-size: 2em;
            color: #3a3a5a;
            animation: arrowBounce 1.5s ease-in-out infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }

        .vector-viz {
            display: flex;
            gap: 4px;
            padding: 10px;
            background: #0a0a12;
            border-radius: 8px;
            border: 2px solid #2a2a4a;
        }

        .vector-cell {
            width: 24px;
            height: 40px;
            border-radius: 4px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            font-size: 0.6em;
            color: #666;
            position: relative;
            background: #1a1a2a;
            overflow: hidden;
        }

        .vector-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            border-radius: 0 0 4px 4px;
            transition: height 0.3s ease;
        }

        .vector-label {
            position: relative;
            z-index: 1;
            padding-bottom: 2px;
        }

        .feed-icon {
            font-size: 2.5em;
            transition: all 0.3s ease;
        }

        .feed-icon.active {
            animation: feedPulseActive 0.3s ease-in-out infinite alternate;
            filter: drop-shadow(0 0 15px #00d4ff) drop-shadow(0 0 30px #00ff88);
        }

        @keyframes feedPulseActive {
            0% { transform: scale(1); }
            100% { transform: scale(1.2); }
        }

        .pixel-grid.active {
            box-shadow:
                0 0 20px rgba(0, 212, 255, 0.5),
                0 0 40px rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }

        .vector-viz.active {
            box-shadow:
                0 0 20px rgba(0, 255, 136, 0.5),
                0 0 40px rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }

        /* INSIGHT PANEL - Superposition explanation */
        .insight-panel {
            margin-top: 20px;
            padding: 25px;
            background: linear-gradient(135deg, #0d0d18 0%, #151528 100%);
            border-radius: 12px;
            border: 1px solid #2a2a4a;
        }

        .insight-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: stretch;
        }

        .insight-card {
            padding: 20px;
            border-radius: 10px;
            border: 1px solid;
        }

        .insight-card.problem {
            background: linear-gradient(135deg, #1a1520 0%, #251828 100%);
            border-color: #ff6b6b40;
        }

        .insight-card.solution {
            background: linear-gradient(135deg, #151a20 0%, #182528 100%);
            border-color: #4ecdc440;
        }

        .insight-title {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .insight-card.problem .insight-title {
            color: #ff6b6b;
        }

        .insight-card.solution .insight-title {
            color: #4ecdc4;
        }

        .insight-arrow {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .arrow-text {
            font-size: 0.8em;
            color: #00d4ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .arrow-symbol {
            font-size: 2.5em;
            color: #00d4ff;
            animation: arrowPulse 2s infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { transform: translateX(0); opacity: 1; }
            50% { transform: translateX(5px); opacity: 0.7; }
        }

        .arrow-subtext {
            font-size: 0.7em;
            color: #666;
            margin-top: 5px;
        }

        .space-label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 10px;
            text-align: center;
        }

        .entangled-neurons {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-bottom: 12px;
            padding: 8px;
            background: #0a0a12;
            border-radius: 6px;
        }

        .entangled-neuron {
            width: 100%;
            height: 24px;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            cursor: help;
        }

        /* Gradient showing multiple features mixed - creates visual "chaos" */
        .entangled-neuron {
            background: linear-gradient(
                var(--angle, 45deg),
                var(--c1) 0%,
                var(--c2) 35%,
                var(--c3) 65%,
                var(--c4, var(--c1)) 100%
            );
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
            animation: shimmer 3s ease-in-out infinite;
            animation-delay: var(--delay, 0s);
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .monosemantic-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            margin-bottom: 12px;
            padding: 8px;
            background: #0a0a12;
            border-radius: 6px;
        }

        .mono-cell {
            width: 100%;
            height: 18px;
            border-radius: 2px;
            background: #1a1a2a;
            transition: all 0.3s ease;
            border: 1px solid #252535;
        }

        .mono-cell.active {
            box-shadow: 0 0 10px currentColor;
            border-color: currentColor;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .polysemantic-label {
            font-size: 0.7em;
            color: #666;
            text-align: center;
            margin-bottom: 15px;
        }

        .highlight-bad {
            color: #ff6b6b;
            font-weight: bold;
        }

        .highlight-good {
            color: #4ecdc4;
            font-weight: bold;
        }

        .feature-overlap, .feature-clean {
            font-size: 0.75em;
            margin-bottom: 15px;
        }

        .overlap-item, .clean-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            background: #0a0a12;
        }

        .overlap-item.dim {
            opacity: 0.5;
        }

        .clean-item.active {
            background: #0a1512;
            border-left: 2px solid #4ecdc4;
        }

        .neuron-badge {
            background: #ff6b6b30;
            color: #ff6b6b;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .feature-badge {
            background: #4ecdc430;
            color: #4ecdc4;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .overlap-text, .clean-text {
            color: #999;
            font-family: 'SF Mono', monospace;
        }

        .curse-text, .solution-text {
            font-size: 0.75em;
            padding: 10px;
            border-radius: 6px;
            line-height: 1.4;
        }

        .curse-text {
            background: #ff6b6b15;
            color: #cc8888;
            border-left: 2px solid #ff6b6b;
        }

        .solution-text {
            background: #4ecdc415;
            color: #88cccc;
            border-left: 2px solid #4ecdc4;
        }

        .math-insight {
            margin-top: 20px;
            padding: 15px;
            background: #0a0a12;
            border-radius: 8px;
            text-align: center;
            font-family: 'SF Mono', monospace;
        }

        .math-insight code {
            color: #00d4ff;
            font-size: 0.9em;
        }

        .math-note {
            display: block;
            margin-top: 8px;
            font-size: 0.75em;
            color: #666;
            font-family: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Activation Visualizer</h1>
        <p class="subtitle">Watch activations flow through model layers, get translated by SAE into interpretable features</p>

        <!-- INPUT IMAGE VISUALIZATION -->
        <div class="input-image-panel" id="inputPanel">
            <div class="input-image-container">
                <div class="input-section">
                    <div class="input-label">Input Image</div>
                    <div class="pixel-grid" id="pixelGrid"></div>
                    <div class="input-type" id="inputTypeLabel">Random Noise</div>
                </div>
                <div class="input-arrow">‚Üí</div>
                <div class="input-section">
                    <div class="input-label">Flattened to Vector</div>
                    <div class="vector-viz" id="vectorViz"></div>
                    <div class="input-type">x ‚àà ‚Ñù‚Å∏</div>
                </div>
                <div class="input-arrow">‚Üí</div>
                <div class="input-section small">
                    <div class="input-label">Feed to Model</div>
                    <div class="feed-icon">‚ö°</div>
                </div>
            </div>
        </div>

        <div class="main-viz">
            <!-- LEFT: Model Layers -->
            <div class="panel" id="modelPanel">
                <div class="panel-title">Model Layers</div>
                <div class="layers-container">
                    <div class="layer">
                        <div class="layer-label">
                            <span>Input</span>
                            <span id="inputDim">dim: 8</span>
                        </div>
                        <div class="layer-neurons" id="inputLayer"></div>
                    </div>

                    <div class="flow-arrow" id="arrow1">&#8595;</div>

                    <div class="layer">
                        <div class="layer-label">
                            <span>L1 (Hidden)</span>
                            <span id="l1Dim">dim: 16</span>
                        </div>
                        <div class="layer-neurons" id="layer1"></div>
                    </div>

                    <div class="flow-arrow" id="arrow2">&#8595;</div>

                    <div class="layer">
                        <div class="layer-label">
                            <span>L2 (Hidden)</span>
                            <span id="l2Dim">dim: 16</span>
                        </div>
                        <div class="layer-neurons" id="layer2"></div>
                    </div>

                    <div class="flow-arrow" id="arrow3">&#8595;</div>

                    <div class="layer">
                        <div class="layer-label">
                            <span>L3 (Output)</span>
                            <span id="l3Dim">dim: 8</span>
                        </div>
                        <div class="layer-neurons" id="layer3"></div>
                    </div>
                </div>
            </div>

            <!-- MIDDLE: SAE -->
            <div class="panel" id="saePanel">
                <div class="panel-title">SAE Translator</div>
                <div class="sae-container">
                    <div class="sae-diagram">
                        <div class="sae-stage">
                            <div class="sae-block encoder-block">
                                ENCODER<br>
                                <small>W_enc @ x + b_enc</small>
                            </div>
                            <div class="sae-arrow" id="encArrow">&#8594;</div>
                        </div>

                        <div class="sae-stage">
                            <div class="sae-block latent-block">
                                SPARSE LATENTS<br>
                                <small>ReLU activation</small>
                            </div>
                        </div>

                        <div style="font-size: 0.75em; color: #666; margin: 10px 0;">Sparse Feature Activations (d_sae = 64)</div>
                        <div class="sparse-grid" id="sparseGrid"></div>

                        <div class="sae-stage">
                            <div class="sae-arrow" id="decArrow">&#8595;</div>
                            <div class="sae-block decoder-block">
                                DECODER<br>
                                <small>W_dec @ z + b_dec</small>
                            </div>
                        </div>
                    </div>

                    <div class="recon-meter">
                        <div class="meter-label">
                            <span>Reconstruction Quality</span>
                            <span id="reconValue">0%</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-fill" id="reconFill" style="width: 0%; background: #44ff88;"></div>
                        </div>
                    </div>

                    <div class="recon-meter">
                        <div class="meter-label">
                            <span>Sparsity (L1)</span>
                            <span id="sparsityValue">0%</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-fill" id="sparsityFill" style="width: 0%; background: #9a4ad9;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- RIGHT: Clean Features -->
            <div class="panel" id="featuresPanel">
                <div class="panel-title">Clean Observations</div>
                <div class="features-container" id="featuresContainer"></div>
            </div>
        </div>

        <!-- SUPERPOSITION INSIGHT PANEL -->
        <div class="insight-panel">
            <div class="insight-grid">
                <div class="insight-card problem">
                    <div class="insight-title">The Problem: Superposition</div>
                    <div class="insight-content">
                        <div class="superposition-viz">
                            <div class="dense-space" id="denseSpace">
                                <div class="space-label">Hidden Layer (d=16)</div>
                                <div class="entangled-neurons" id="entangledNeurons"></div>
                                <div class="polysemantic-label">Each neuron encodes <span class="highlight-bad">multiple features</span></div>
                            </div>
                            <div class="feature-overlap">
                                <div class="overlap-item">
                                    <span class="neuron-badge">N‚ÇÉ</span>
                                    <span class="overlap-text">= 0.7¬∑dog + 0.3¬∑fur + 0.2¬∑brown</span>
                                </div>
                                <div class="overlap-item">
                                    <span class="neuron-badge">N‚Çá</span>
                                    <span class="overlap-text">= 0.5¬∑eye + 0.4¬∑round + 0.3¬∑black</span>
                                </div>
                                <div class="overlap-item dim">
                                    <span class="neuron-badge">N‚ÇÅ‚ÇÇ</span>
                                    <span class="overlap-text">= 0.6¬∑edge + 0.2¬∑texture + ...</span>
                                </div>
                            </div>
                        </div>
                        <div class="curse-text">
                            <strong>Curse of Dimensionality:</strong> ~10¬≥ features packed into 16 neurons.
                            Cannot enumerate or search this entangled space.
                        </div>
                    </div>
                </div>

                <div class="insight-arrow">
                    <div class="arrow-text">SAE</div>
                    <div class="arrow-symbol">‚Üí</div>
                    <div class="arrow-subtext">Decompose</div>
                </div>

                <div class="insight-card solution">
                    <div class="insight-title">The Solution: Sparse Decomposition</div>
                    <div class="insight-content">
                        <div class="sparse-space">
                            <div class="space-label">SAE Latents (d=64, ~5 active)</div>
                            <div class="monosemantic-grid" id="monosemGrid"></div>
                            <div class="polysemantic-label">Each feature is <span class="highlight-good">independently interpretable</span></div>
                        </div>
                        <div class="feature-clean">
                            <div class="clean-item active">
                                <span class="feature-badge">F‚ÇÅ‚Çá</span>
                                <span class="clean-text">= "dog-ness" (0.92)</span>
                            </div>
                            <div class="clean-item active">
                                <span class="feature-badge">F‚ÇÑ‚ÇÉ</span>
                                <span class="clean-text">= "fur texture" (0.78)</span>
                            </div>
                            <div class="clean-item">
                                <span class="feature-badge">F‚ÇÖ‚ÇÅ</span>
                                <span class="clean-text">= "brown color" (0.00)</span>
                            </div>
                        </div>
                        <div class="solution-text">
                            <strong>Independent Components:</strong> Each feature understood on its own.
                            Searchable, enumerable, interpretable.
                        </div>
                    </div>
                </div>
            </div>

            <div class="math-insight">
                <code>x ‚àà ‚Ñù<sup>d</sup> ‚Üí z = ReLU(W<sub>enc</sub>x + b) ‚àà ‚Ñù<sup>D</sup> where D >> d, ||z||‚ÇÄ << D</code>
                <span class="math-note">Expand to high-dim sparse space where features don't interfere</span>
            </div>
        </div>

        <!-- BOTTOM: Timeline -->
        <div class="timeline-panel">
            <div class="timeline-header">
                <div class="timeline-title">Activation Flow Timeline</div>
                <div id="flowStatus" style="font-size: 0.8em; color: #666;">Ready</div>
            </div>
            <div class="timeline-viz">
                <div class="timeline-node">
                    <div class="timeline-icon input" id="tInput">x</div>
                    <div class="timeline-label">Input</div>
                </div>
                <div class="timeline-connector" id="c1"></div>
                <div class="timeline-node">
                    <div class="timeline-icon l1" id="tL1">L1</div>
                    <div class="timeline-label">Layer 1</div>
                </div>
                <div class="timeline-connector" id="c2"></div>
                <div class="timeline-node">
                    <div class="timeline-icon l2" id="tL2">L2</div>
                    <div class="timeline-label">Layer 2</div>
                </div>
                <div class="timeline-connector" id="c3"></div>
                <div class="timeline-node">
                    <div class="timeline-icon l3" id="tL3">L3</div>
                    <div class="timeline-label">Layer 3</div>
                </div>
                <div class="timeline-connector" id="c4"></div>
                <div class="timeline-node">
                    <div class="timeline-icon encoder" id="tEnc">Enc</div>
                    <div class="timeline-label">Encoder</div>
                </div>
                <div class="timeline-connector" id="c5"></div>
                <div class="timeline-node">
                    <div class="timeline-icon latent" id="tLat">z</div>
                    <div class="timeline-label">Sparse z</div>
                </div>
                <div class="timeline-connector" id="c6"></div>
                <div class="timeline-node">
                    <div class="timeline-icon decoder" id="tDec">Dec</div>
                    <div class="timeline-label">Decoder</div>
                </div>
                <div class="timeline-connector" id="c7"></div>
                <div class="timeline-node">
                    <div class="timeline-icon output" id="tOut">y</div>
                    <div class="timeline-label">Features</div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="btn-primary" onclick="runForwardPass()">Run Forward Pass</button>
            <button class="btn-secondary selected" id="btnNoise" onclick="randomizeInput()">üé≤ Random Noise</button>
            <button class="btn-secondary" id="btnDog" onclick="setPreset('dog')">üêï Dog</button>
            <button class="btn-secondary" id="btnCat" onclick="setPreset('cat')">üê± Cat</button>
            <button class="btn-secondary" id="btnSparse" onclick="setPreset('sparse')">‚ö° Sparse</button>
            <button class="btn-secondary" id="autoBtn" onclick="toggleAutoPlay()">Auto Play</button>
        </div>

        <!-- Stats -->
        <div class="stats-bar">
            <div class="stat">
                <div class="stat-value" id="activeNeurons">0</div>
                <div class="stat-label">Active Features</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="sparsityRatio">0%</div>
                <div class="stat-label">Sparsity</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="reconError">0.00</div>
                <div class="stat-label">Recon Error</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="topFeature">-</div>
                <div class="stat-label">Top Feature</div>
            </div>
        </div>
    </div>

    <script>
        // Model dimensions
        const INPUT_DIM = 8;
        const HIDDEN_DIM = 16;
        const OUTPUT_DIM = 8;
        const SAE_DIM = 64;

        // Feature names for interpretability
        const FEATURE_NAMES = [
            'Edge Detection', 'Color Saturation', 'Texture Pattern',
            'Shape Curvature', 'Spatial Position', 'Contrast Level',
            'Frequency Content', 'Object Boundary', 'Background Signal',
            'Foreground Focus', 'Motion Vector', 'Depth Cue'
        ];

        // State
        let inputActivations = new Array(INPUT_DIM).fill(0);
        let layer1Activations = new Array(HIDDEN_DIM).fill(0);
        let layer2Activations = new Array(HIDDEN_DIM).fill(0);
        let layer3Activations = new Array(OUTPUT_DIM).fill(0);
        let sparseActivations = new Array(SAE_DIM).fill(0);
        let featureActivations = [];
        let autoPlayInterval = null;
        let isAnimating = false;
        let currentInputType = 'noise';
        let pixelData = new Array(64).fill(0); // 8x8 image

        // Predefined patterns (8x8 pixel grids)
        const PATTERNS = {
            dog: [
                0.1, 0.2, 0.3, 0.3, 0.3, 0.3, 0.2, 0.1,
                0.2, 0.8, 0.9, 0.7, 0.7, 0.9, 0.8, 0.2,
                0.3, 0.9, 0.2, 0.9, 0.9, 0.2, 0.9, 0.3,
                0.3, 0.8, 0.9, 0.9, 0.9, 0.9, 0.8, 0.3,
                0.2, 0.7, 0.9, 0.3, 0.3, 0.9, 0.7, 0.2,
                0.2, 0.5, 0.8, 0.9, 0.9, 0.8, 0.5, 0.2,
                0.1, 0.3, 0.5, 0.6, 0.6, 0.5, 0.3, 0.1,
                0.1, 0.2, 0.2, 0.3, 0.3, 0.2, 0.2, 0.1
            ],
            cat: [
                0.9, 0.3, 0.1, 0.1, 0.1, 0.1, 0.3, 0.9,
                0.5, 0.8, 0.5, 0.3, 0.3, 0.5, 0.8, 0.5,
                0.2, 0.7, 0.9, 0.7, 0.7, 0.9, 0.7, 0.2,
                0.2, 0.6, 0.3, 0.9, 0.9, 0.3, 0.6, 0.2,
                0.1, 0.5, 0.7, 0.5, 0.5, 0.7, 0.5, 0.1,
                0.1, 0.4, 0.6, 0.9, 0.9, 0.6, 0.4, 0.1,
                0.1, 0.3, 0.4, 0.5, 0.5, 0.4, 0.3, 0.1,
                0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.1, 0.1
            ],
            sparse: [
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.9, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.8, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
            ]
        };

        // Color maps for different input types
        const COLOR_MAPS = {
            dog: (v) => `rgb(${Math.floor(139 + v*80)}, ${Math.floor(90 + v*60)}, ${Math.floor(43 + v*40)})`, // Browns
            cat: (v) => `rgb(${Math.floor(100 + v*100)}, ${Math.floor(100 + v*100)}, ${Math.floor(110 + v*100)})`, // Grays
            noise: (v) => `rgb(${Math.floor(v*200)}, ${Math.floor(v*220)}, ${Math.floor(v*255)})`, // Blue-ish
            sparse: (v) => v > 0.5 ? `rgb(${Math.floor(v*255)}, ${Math.floor(v*100)}, ${Math.floor(v*100)})` : '#1a1a2a' // Red spots
        };

        // Simulated weights (would be learned in real SAE)
        let W_enc = [];
        let W_dec = [];

        function initializeWeights() {
            // Random encoder weights
            W_enc = [];
            for (let i = 0; i < SAE_DIM; i++) {
                W_enc.push(new Array(HIDDEN_DIM).fill(0).map(() => (Math.random() - 0.5) * 0.5));
            }
            // Decoder is transpose of encoder (tied weights)
            W_dec = W_enc;
        }

        function relu(x) {
            return Math.max(0, x);
        }

        function getColorForValue(val) {
            if (val < 0.1) return '#1a1a2a';
            if (val < 0.3) return '#2a4a3a';
            if (val < 0.5) return '#44aa66';
            if (val < 0.7) return '#ffaa44';
            return '#ff4444';
        }

        function getColorClass(val) {
            if (val < 0.2) return 'bg-zero';
            if (val < 0.4) return 'bg-low';
            if (val < 0.7) return 'bg-mid';
            return 'bg-high';
        }

        function renderLayer(containerId, activations, cols = 8) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

            activations.forEach((val, idx) => {
                const neuron = document.createElement('div');
                neuron.className = 'neuron';
                neuron.style.background = getColorForValue(val);
                neuron.setAttribute('data-val', val.toFixed(2));
                neuron.title = `Neuron ${idx}: ${(val * 100).toFixed(0)}%`;
                container.appendChild(neuron);
            });
        }

        function renderSparseGrid() {
            const container = document.getElementById('sparseGrid');
            container.innerHTML = '';

            sparseActivations.forEach((val, idx) => {
                const cell = document.createElement('div');
                cell.className = 'sparse-cell' + (val > 0.1 ? ' active' : '');
                cell.style.background = getColorForValue(val);
                cell.title = `Feature ${idx}: ${(val * 100).toFixed(0)}%`;
                container.appendChild(cell);
            });
        }

        function renderFeatures() {
            const container = document.getElementById('featuresContainer');
            container.innerHTML = '';

            // Get top 8 features
            const indexed = sparseActivations.map((v, i) => ({val: v, idx: i}));
            indexed.sort((a, b) => b.val - a.val);
            const topFeatures = indexed.slice(0, 8);

            topFeatures.forEach((f, rank) => {
                const name = FEATURE_NAMES[f.idx % FEATURE_NAMES.length];
                const percent = (f.val * 100).toFixed(0);
                const isHighlighted = f.val > 0.5;

                const row = document.createElement('div');
                row.className = 'feature-row' + (isHighlighted ? ' highlighted' : '');

                let barColor = '#2a4a3a';
                if (f.val > 0.7) barColor = '#ff4444';
                else if (f.val > 0.4) barColor = '#ffaa44';
                else if (f.val > 0.1) barColor = '#44ff88';

                row.innerHTML = `
                    <div class="feature-header">
                        <span class="feature-name">#${f.idx} ${name}</span>
                        <span class="feature-value" style="color: ${barColor}">${percent}%</span>
                    </div>
                    <div class="feature-bar">
                        <div class="feature-fill" style="width: ${percent}%; background: ${barColor};"></div>
                    </div>
                `;
                container.appendChild(row);
            });

            // Update stats
            const activeCount = sparseActivations.filter(v => v > 0.1).length;
            const sparsity = ((SAE_DIM - activeCount) / SAE_DIM * 100).toFixed(0);

            document.getElementById('activeNeurons').textContent = activeCount;
            document.getElementById('sparsityRatio').textContent = sparsity + '%';
            document.getElementById('topFeature').textContent = topFeatures[0].val > 0.1 ?
                FEATURE_NAMES[topFeatures[0].idx % FEATURE_NAMES.length].split(' ')[0] : '-';

            // Update meters
            const reconQuality = Math.random() * 20 + 75; // Simulated
            document.getElementById('reconValue').textContent = reconQuality.toFixed(0) + '%';
            document.getElementById('reconFill').style.width = reconQuality + '%';

            document.getElementById('sparsityValue').textContent = sparsity + '%';
            document.getElementById('sparsityFill').style.width = sparsity + '%';

            document.getElementById('reconError').textContent = ((100 - reconQuality) / 100).toFixed(3);

            // Sync the insight panel monosemantic grid with live data
            renderMonosemGrid();
        }

        function simulateForwardPass() {
            // L1 = ReLU(W1 @ input)
            layer1Activations = new Array(HIDDEN_DIM).fill(0).map((_, i) => {
                let sum = 0;
                for (let j = 0; j < INPUT_DIM; j++) {
                    sum += inputActivations[j] * (Math.sin(i * j * 0.5) * 0.5 + 0.5);
                }
                return relu(sum / INPUT_DIM + (Math.random() - 0.5) * 0.1);
            });

            // L2 = ReLU(W2 @ L1)
            layer2Activations = new Array(HIDDEN_DIM).fill(0).map((_, i) => {
                let sum = 0;
                for (let j = 0; j < HIDDEN_DIM; j++) {
                    sum += layer1Activations[j] * (Math.cos(i * j * 0.3) * 0.5 + 0.5);
                }
                return relu(sum / HIDDEN_DIM + (Math.random() - 0.5) * 0.1);
            });

            // L3 = ReLU(W3 @ L2)
            layer3Activations = new Array(OUTPUT_DIM).fill(0).map((_, i) => {
                let sum = 0;
                for (let j = 0; j < HIDDEN_DIM; j++) {
                    sum += layer2Activations[j] * (Math.sin((i + 1) * j * 0.4) * 0.5 + 0.5);
                }
                return relu(sum / HIDDEN_DIM + (Math.random() - 0.5) * 0.1);
            });

            // SAE Encoder: z = ReLU(W_enc @ L2 + b)
            sparseActivations = new Array(SAE_DIM).fill(0).map((_, i) => {
                let sum = 0;
                for (let j = 0; j < HIDDEN_DIM; j++) {
                    sum += layer2Activations[j] * W_enc[i][j];
                }
                // Apply sparsity via ReLU with bias
                const bias = -0.3 + (i % 8) * 0.05; // Varying thresholds
                return relu(sum + bias);
            });

            // Normalize sparse activations
            const maxSparse = Math.max(...sparseActivations, 0.01);
            sparseActivations = sparseActivations.map(v => Math.min(v / maxSparse, 1));
        }

        async function runForwardPass() {
            if (isAnimating) return;
            isAnimating = true;

            document.getElementById('flowStatus').textContent = 'Processing...';

            // Reset all timeline states
            const timelineIds = ['tInput', 'tL1', 'tL2', 'tL3', 'tEnc', 'tLat', 'tDec', 'tOut'];
            const connectorIds = ['c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7'];
            timelineIds.forEach(id => document.getElementById(id).classList.remove('active'));
            connectorIds.forEach(id => document.getElementById(id).classList.remove('active'));

            // Reset layer and SAE block active states
            document.querySelectorAll('.layer').forEach(l => l.classList.remove('active'));
            document.querySelectorAll('.sae-block').forEach(b => b.classList.remove('active'));
            clearAllPanelGlow();

            // Get panel elements
            const inputPanelEl = document.getElementById('inputPanel');
            const modelPanelEl = document.getElementById('modelPanel');
            const saePanelEl = document.getElementById('saePanel');
            const featuresPanelEl = document.getElementById('featuresPanel');

            // Get layer elements
            const layers = document.querySelectorAll('.layer');
            const inputLayerEl = layers[0];
            const l1El = layers[1];
            const l2El = layers[2];
            const l3El = layers[3];

            // Step 0: Highlight input image panel
            const pixelGridEl = document.getElementById('pixelGrid');
            const vectorVizEl = document.getElementById('vectorViz');
            const feedIconEl = document.querySelector('.feed-icon');

            inputPanelEl.classList.add('active');
            pixelGridEl.classList.add('active');
            await sleep(300);
            vectorVizEl.classList.add('active');
            await sleep(300);
            feedIconEl.classList.add('active');
            await sleep(300);

            // Step 1: Transition to Model panel
            inputPanelEl.classList.remove('active');
            modelPanelEl.classList.add('active');
            document.getElementById('tInput').classList.add('active');
            inputLayerEl.classList.add('active');
            renderLayer('inputLayer', inputActivations);
            await sleep(400);

            // Clear input panel element glows
            pixelGridEl.classList.remove('active');
            vectorVizEl.classList.remove('active');
            feedIconEl.classList.remove('active');

            // Step 2: L1
            inputLayerEl.classList.remove('active');
            document.getElementById('c1').classList.add('active');
            document.getElementById('arrow1').classList.add('active');
            await sleep(250);
            simulateForwardPass();
            document.getElementById('tL1').classList.add('active');
            l1El.classList.add('active');
            renderLayer('layer1', layer1Activations);
            await sleep(400);
            document.getElementById('arrow1').classList.remove('active');

            // Step 3: L2
            l1El.classList.remove('active');
            document.getElementById('c2').classList.add('active');
            document.getElementById('arrow2').classList.add('active');
            await sleep(250);
            document.getElementById('tL2').classList.add('active');
            l2El.classList.add('active');
            renderLayer('layer2', layer2Activations);
            await sleep(400);
            document.getElementById('arrow2').classList.remove('active');

            // Step 4: L3
            l2El.classList.remove('active');
            document.getElementById('c3').classList.add('active');
            document.getElementById('arrow3').classList.add('active');
            await sleep(250);
            document.getElementById('tL3').classList.add('active');
            l3El.classList.add('active');
            renderLayer('layer3', layer3Activations);
            await sleep(400);
            document.getElementById('arrow3').classList.remove('active');
            l3El.classList.remove('active');

            // Step 5: SAE Encoder - Transition to SAE panel
            modelPanelEl.classList.remove('active');
            saePanelEl.classList.add('active');
            document.getElementById('c4').classList.add('active');
            document.getElementById('encArrow').classList.add('active');
            document.querySelector('.encoder-block').classList.add('active');
            await sleep(200);
            document.getElementById('tEnc').classList.add('active');
            await sleep(400);

            // Step 6: Sparse Latents
            document.getElementById('c5').classList.add('active');
            document.querySelector('.encoder-block').classList.remove('active');
            document.querySelector('.latent-block').classList.add('active');
            await sleep(200);
            document.getElementById('tLat').classList.add('active');
            document.getElementById('encArrow').classList.remove('active');
            renderSparseGrid();
            await sleep(500);

            // Step 7: Decoder
            document.getElementById('c6').classList.add('active');
            document.querySelector('.latent-block').classList.remove('active');
            document.querySelector('.decoder-block').classList.add('active');
            document.getElementById('decArrow').classList.add('active');
            await sleep(200);
            document.getElementById('tDec').classList.add('active');
            await sleep(400);
            document.getElementById('decArrow').classList.remove('active');
            document.querySelector('.decoder-block').classList.remove('active');

            // Step 8: Output Features - Transition to Features panel
            saePanelEl.classList.remove('active');
            featuresPanelEl.classList.add('active');
            document.getElementById('c7').classList.add('active');
            await sleep(200);
            document.getElementById('tOut').classList.add('active');
            renderFeatures();

            // Hold the features panel glow briefly then clear
            await sleep(800);
            featuresPanelEl.classList.remove('active');

            document.getElementById('flowStatus').textContent = 'Complete';
            isAnimating = false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function renderPixelGrid() {
            const container = document.getElementById('pixelGrid');
            if (!container) return;
            container.innerHTML = '';

            const colorMap = COLOR_MAPS[currentInputType] || COLOR_MAPS.noise;

            pixelData.forEach((val, idx) => {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                pixel.style.background = colorMap(val);
                pixel.title = `Pixel [${Math.floor(idx/8)},${idx%8}]: ${val.toFixed(2)}`;
                container.appendChild(pixel);
            });

            // Update label
            const label = document.getElementById('inputTypeLabel');
            if (label) {
                const labels = {
                    dog: 'üêï Dog Face',
                    cat: 'üê± Cat Face',
                    noise: 'üìä Random Noise',
                    sparse: '‚ö° Sparse Signal'
                };
                label.textContent = labels[currentInputType] || 'Input';
            }
        }

        function renderVectorViz() {
            const container = document.getElementById('vectorViz');
            if (!container) return;
            container.innerHTML = '';

            inputActivations.forEach((val, idx) => {
                const cell = document.createElement('div');
                cell.className = 'vector-cell';

                const fill = document.createElement('div');
                fill.className = 'vector-fill';
                fill.style.height = (val * 100) + '%';
                fill.style.background = getColorForValue(val);

                const label = document.createElement('span');
                label.className = 'vector-label';
                label.textContent = `x${idx}`;

                cell.appendChild(fill);
                cell.appendChild(label);
                cell.title = `x[${idx}] = ${val.toFixed(3)}`;
                container.appendChild(cell);
            });
        }

        function pixelDataToActivations() {
            // Convert 8x8 pixel grid to 8-dim input vector
            // Average each row to get 8 values
            inputActivations = [];
            for (let row = 0; row < 8; row++) {
                let rowSum = 0;
                for (let col = 0; col < 8; col++) {
                    rowSum += pixelData[row * 8 + col];
                }
                inputActivations.push(rowSum / 8);
            }
        }

        function updateSelectedButton(type) {
            // Clear all selected states
            document.querySelectorAll('.controls .btn-secondary').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Set selected state based on type
            const btnMap = {
                'noise': 'btnNoise',
                'dog': 'btnDog',
                'cat': 'btnCat',
                'sparse': 'btnSparse'
            };

            const btnId = btnMap[type];
            if (btnId) {
                const btn = document.getElementById(btnId);
                if (btn) btn.classList.add('selected');
            }
        }

        function clearAllPanelGlow() {
            document.getElementById('inputPanel').classList.remove('active');
            document.getElementById('modelPanel').classList.remove('active');
            document.getElementById('saePanel').classList.remove('active');
            document.getElementById('featuresPanel').classList.remove('active');
        }

        function randomizeInput() {
            currentInputType = 'noise';
            pixelData = new Array(64).fill(0).map(() => Math.random());
            pixelDataToActivations();
            renderPixelGrid();
            renderVectorViz();
            renderLayer('inputLayer', inputActivations);
            updateSelectedButton('noise');
        }

        function setPreset(type) {
            if (type === 'sparse') {
                currentInputType = 'sparse';
                pixelData = [...PATTERNS.sparse];
            } else if (type === 'dense' || type === 'dog') {
                currentInputType = 'dog';
                pixelData = [...PATTERNS.dog];
            } else if (type === 'cat') {
                currentInputType = 'cat';
                pixelData = [...PATTERNS.cat];
            }
            pixelDataToActivations();
            renderPixelGrid();
            renderVectorViz();
            renderLayer('inputLayer', inputActivations);
            updateSelectedButton(currentInputType);
        }

        let autoPlayIndex = 0;
        const autoPlaySequence = ['dog', 'cat', 'noise', 'sparse'];

        function toggleAutoPlay() {
            const btn = document.getElementById('autoBtn');
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                btn.classList.remove('active');
                btn.textContent = 'Auto Play';
            } else {
                btn.classList.add('active');
                btn.textContent = 'Stop Auto';
                // Run immediately first
                cycleAutoPlay();
                autoPlayInterval = setInterval(cycleAutoPlay, 4000);
            }
        }

        function cycleAutoPlay() {
            if (isAnimating) return;

            const inputType = autoPlaySequence[autoPlayIndex];
            autoPlayIndex = (autoPlayIndex + 1) % autoPlaySequence.length;

            if (inputType === 'noise') {
                randomizeInput();
            } else {
                setPreset(inputType);
            }
            runForwardPass();
        }

        // Render the superposition insight panels
        function renderInsightPanels() {
            renderEntangledNeurons();
            renderMonosemGrid();
        }

        function renderEntangledNeurons() {
            const entangledContainer = document.getElementById('entangledNeurons');
            if (!entangledContainer) return;
            entangledContainer.innerHTML = '';

            // Color palette for "chaotic" polysemantic mixing
            const palette = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4ecdc4', '#a855f7', '#ff9f43', '#54a0ff', '#5f27cd'];

            for (let i = 0; i < 16; i++) {
                const neuron = document.createElement('div');
                neuron.className = 'entangled-neuron';

                // Each neuron gets a unique mix of 3-4 colors at random angles
                const c1 = palette[i % palette.length];
                const c2 = palette[(i + 3) % palette.length];
                const c3 = palette[(i + 5) % palette.length];
                const c4 = palette[(i + 7) % palette.length];
                const angle = 30 + (i * 23) % 120; // Varied angles

                neuron.style.setProperty('--c1', c1);
                neuron.style.setProperty('--c2', c2);
                neuron.style.setProperty('--c3', c3);
                neuron.style.setProperty('--c4', c4);
                neuron.style.setProperty('--angle', angle + 'deg');
                neuron.style.setProperty('--delay', (i * 0.15) + 's');

                neuron.title = `Neuron ${i}: polysemantic\nEncodes mixture of features:\n‚Ä¢ ${(Math.random()*0.4+0.3).toFixed(2)} feature A\n‚Ä¢ ${(Math.random()*0.3+0.2).toFixed(2)} feature B\n‚Ä¢ ${(Math.random()*0.2+0.1).toFixed(2)} feature C`;
                entangledContainer.appendChild(neuron);
            }
        }

        function renderMonosemGrid() {
            const monoContainer = document.getElementById('monosemGrid');
            if (!monoContainer) return;
            monoContainer.innerHTML = '';

            // Get top active indices from actual sparse activations
            const indexed = sparseActivations.map((v, i) => ({val: v, idx: i}));
            indexed.sort((a, b) => b.val - a.val);
            const topActive = indexed.filter(x => x.val > 0.1).slice(0, 8);
            const activeIndices = topActive.map(x => x.idx);

            for (let i = 0; i < 64; i++) {
                const cell = document.createElement('div');
                cell.className = 'mono-cell';

                const activeEntry = topActive.find(x => x.idx === i);
                if (activeEntry) {
                    cell.classList.add('active');
                    // Color based on activation strength
                    if (activeEntry.val > 0.7) {
                        cell.style.background = '#4ecdc4';
                        cell.style.color = '#4ecdc4';
                    } else if (activeEntry.val > 0.4) {
                        cell.style.background = '#6bcb77';
                        cell.style.color = '#6bcb77';
                    } else {
                        cell.style.background = '#a855f7';
                        cell.style.color = '#a855f7';
                    }
                    cell.title = `Feature ${i}: ACTIVE (${(activeEntry.val * 100).toFixed(0)}%)\nMonosemantic - single concept`;
                } else {
                    cell.title = `Feature ${i}: inactive (sparse)`;
                }

                monoContainer.appendChild(cell);
            }

            // Update the feature decomposition text
            updateFeatureDecompositionText(topActive);
        }

        function updateFeatureDecompositionText(topActive) {
            const cleanItems = document.querySelectorAll('.insight-card.solution .clean-item');
            if (cleanItems.length >= 3 && topActive.length >= 2) {
                const featureNames = ['dog-ness', 'fur texture', 'edge pattern', 'color region', 'shape curve', 'motion blur'];

                // Update first two as active
                if (topActive[0]) {
                    const badge1 = cleanItems[0].querySelector('.feature-badge');
                    const text1 = cleanItems[0].querySelector('.clean-text');
                    if (badge1) badge1.textContent = `F${topActive[0].idx}`;
                    if (text1) text1.textContent = `= "${featureNames[topActive[0].idx % featureNames.length]}" (${topActive[0].val.toFixed(2)})`;
                }
                if (topActive[1]) {
                    const badge2 = cleanItems[1].querySelector('.feature-badge');
                    const text2 = cleanItems[1].querySelector('.clean-text');
                    if (badge2) badge2.textContent = `F${topActive[1].idx}`;
                    if (text2) text2.textContent = `= "${featureNames[topActive[1].idx % featureNames.length]}" (${topActive[1].val.toFixed(2)})`;
                }
            }
        }

        // Initialize
        function init() {
            initializeWeights();

            // Initialize with random noise
            currentInputType = 'noise';
            pixelData = new Array(64).fill(0).map(() => Math.random());
            pixelDataToActivations();

            // Render input visualization
            renderPixelGrid();
            renderVectorViz();

            // Initialize layers
            renderLayer('inputLayer', inputActivations);
            renderLayer('layer1', new Array(HIDDEN_DIM).fill(0));
            renderLayer('layer2', new Array(HIDDEN_DIM).fill(0));
            renderLayer('layer3', new Array(OUTPUT_DIM).fill(0));

            // Initialize sparse grid
            sparseActivations = new Array(SAE_DIM).fill(0);
            renderSparseGrid();

            // Initialize features
            renderFeatures();

            // Initialize insight panels
            renderInsightPanels();
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
